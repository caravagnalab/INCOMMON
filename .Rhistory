density = numerical_integral(
stride = 0.01,
NV = NV,
DP = DP,
m = m,
pl = pl,
rho = rho,
purity = purity,
purity_error = purity_error
)
density
density %>% plot()
#' Compute model likelihood
#'
#' @param NV Number of reads with the variant.
#' @param DP Sequencing coverage of the mutated genome site.
#' @param prob Success probability (expected VAF).
#' @param rho The over-dispersion parameter.
#' @param purity_error Standard deviation of the Beta distribution over the
#' sample purity measure.
#' @param purity The estimated purity of the sample.
#' @return A vector of probability densities (from NV = 1 to NV = DP).
#' @export
#' @importFrom purrr reduce
#' @examples
#'compute_likelihood(
#' NV = 170,
#' DP = 200,
#' prob = 0.5,
#' rho = 0.01
#')
compute_likelihood = function(NV, DP, m, pl, prob, rho, purity, purity_error) {
# Functions for the compund beta model
expected_vaf = function(pu, m, pl){
f = (m * pu)/(2*(1 - pu) + (pl * pu))
return(f)
}
alpha_beta_pi <- function(purity_mean, purity_variance) {
alpha = purity_mean * (((purity_mean * (1 - purity_mean)) / (purity_variance)) - 1)
beta = (1 - purity_mean) * (((purity_mean * (1 - purity_mean)) / (purity_variance)) - 1)
return(c(alpha, beta))
}
# Function to compute the alpha_f(p) and beta_f(p) for f | p, rho
alpha_beta_f <- function(pu, rho, m, pl) {
mean_f <- expected_vaf(pu = pu, m = m, pl = pl)
precision <- (1 - rho) / rho
alpha <- precision * mean_f
beta <- precision * (1 - mean_f)
return(c(alpha, beta))
}
# Function to evaluate the integrand for P(x) over f and p
integrand_beta <- function(x, N, f, pu, m, pl, rho, purity, purity_error) {
ab_f = alpha_beta_f(pu = pu, rho = rho, m = m, pl = pl) # fix over-dispersion coefficient and dependency of f on pi
alpha_f <- ab_f[1]
beta_f <- ab_f[2]
ab_pi = alpha_beta_pi(purity_mean = purity, purity_variance = purity_error**2) # fix mean purity to input one and variance to fixed value
alpha_pi <- ab_pi[1]
beta_pi <- ab_pi[2]
# Probability mass function of binomial and density of Beta for f
out = dbinom(x, size = N, prob = f) * dbeta(f, alpha_f, beta_f) * dbeta(pu, alpha_pi, beta_pi)
out[is.na(out)] = 0
return(out)
}
numerical_integral = function(stride = 0.01,
NV,
DP,
m,
pl,
rho,
purity,
purity_error) {
vals = expand.grid(purity = seq(0, 1 - 1e-16, stride),
freq = seq(0, 1, stride)) %>% dplyr::as_tibble()
lapply(1:nrow(vals), function(i) {
pu = vals[i, ]$purity
f = vals[i, ]$freq
integrand_beta(
x = NV,
N = DP,
f = f,
pu = pu,
m = m,
pl = pl,
rho = rho,
purity = purity,
purity_error = purity_error
) * stride * stride
}) %>% purrr::reduce(., `+`)
}
if(purity_error == 0){
density = VGAM::dbetabinom(
x = NV,
size = DP,
prob = prob,
rho = rho
)
} else {
max_purity_error = sqrt((purity)*(1 - purity))
if(purity_error >= max_purity_error){
cli_alert_warning(
text ="Maximum purity error is {.field {round(max_purity_error, 2)}}, input {.field {purity_error}}")
}
density = numerical_integral(
stride = 0.01,
NV = NV,
DP = DP,
m = m,
pl = pl,
rho = rho,
purity = purity,
purity_error = purity_error
)
}
return(density)
}
DP = 837
NV_x = 1:DP
multiplicity = 1
ploidy =2
expected_peak
expected_peak = .15
rho
rho = .01
purity
purity = .3
purity_error
purity_error = .1
# Beta-Binomial likelihood distribution
likelihood = compute_likelihood(
NV = NV_x,
DP = DP,
m = multiplicity,
pl = ploidy,
prob = expected_peak,
rho = rho,
purity = purity,
purity_error = purity_error)
likelihood
likelihood %>% plot()
posterior = prior*likelihood
posterior
posterior = prior*likelihood
posterior
prior
#' Compute model posterior and entropy
#'
#' @param NV Number of reads with the variant.
#' @param DP Sequencing coverage of the mutated genome site.
#' @param gene Gene name or symbol.
#' @param priors Prior distribution.
#' @param purity Purity of the sample.
#' @param tumor_type Tumor type of the sample.
#' @param entropy_cutoff Cut-off on entropy for Tier-1/Tier-2 distinction.
#' @param rho The over-dispersion parameter.
#' @param karyotypes Karyotypes to be included among the possible classes.
#' @param purity_error Standard deviation of the Beta distribution over the
#' sample purity measure.
#' @param silent Whether to show printed output.
#' @return A table including ploidy, multiplicity, posterior probability,
#' and classification entropy.
#' @export
#' @importFrom dplyr filter mutate rename select %>%
#' @examples
#'compute_posterior(
#' NV = 170,
#' DP = 200,
#' gene = 'TP53',
#' priors = pcawg_priors,
#' tumor_type = 'PAAD',
#' purity = 0.9,
#' entropy_cutoff = 0.2,
#' rho = 0.01,
#' karyotypes = c("1:0", "1:1", "2:0", "2:1", "2:2")
#')
compute_posterior = function(NV,
DP,
gene,
priors = NULL,
tumor_type,
purity,
entropy_cutoff,
rho = 0.01,
karyotypes,
purity_error,
silent = FALSE)
{
NV_x = 1:DP
# Density
db = function(Major, minor, prior, gene)
{
expected_vaf_data = CNAqc:::expected_vaf_peak(Major, minor, purity)
expected_peaks = expected_vaf_data$peak
lapply(expected_peaks %>% seq_along(), function(p) {
# Classification label
label = paste0(Major + minor, 'N (Mutated: ', p, "N)")
if(is.data.frame(prior)){
if(!(label %in% prior$label) & !silent) cli::cli_alert_danger("Incomplete prior distribution!")
stopifnot(label %in% prior$label)
prior = prior %>% dplyr::filter(label == !!label) %>% dplyr::pull(p)
}
# Expected VAF peak of mixture component
expected_peak = expected_peaks[p]
multiplicity = expected_vaf_data[p,]$mutation_multiplicity
ploidy = strsplit(expected_vaf_data[p,]$karyotype, split = ":")[[1]] %>%
as.integer() %>% sum()
# Beta-Binomial likelihood distribution
likelihood = compute_likelihood(
NV = NV_x,
DP = DP,
m = multiplicity,
pl = ploidy,
prob = expected_peak,
rho = rho,
purity = purity,
purity_error = purity_error)
# # Posterior distribution
# if (is.null(priors)){
#   prior = 1
# } else {
#   prior = get_prior(priors, gene, tumor_type, label)
# }
posterior = prior*likelihood
# Output
out = data.frame(
value = posterior,
NV = NV_x,
Major = Major,
minor = minor,
ploidy = Major + minor,
multiplicity = p,
karyotype = paste0(Major, ":", minor),
label = label,
peak = expected_peak,
purity_error = purity_error
)
out
}) %>%
do.call(dplyr::bind_rows, .)
}
if(is.na(purity)){
if(!silent) cli_alert_warning(text =
"With purity {.field {purity}} classification is not possible."
)
return(dplyr::tibble(ploidy = NA,
multiplicity = NA,
entropy = NA,
label = NA,
density = list(NULL)))
}
# Compute posterior distribution of 0 < NV <= DP for each component of the mixture (karyotype)
# Prior distribution
if (is.null(priors)){
prior = 1
} else {
prior = get_prior(priors, gene, tumor_type, silent = silent)
}
posterior = lapply(karyotypes, function(k) {
alleles = strsplit(k, split = ":")[[1]] %>% as.integer()
db(Major = alleles[1],
minor = alleles[2],
prior =  prior,
gene = gene)
}) %>%
dplyr::bind_rows()
# Compute entropy
posterior = posterior %>%
dplyr::group_by(NV) %>%
dplyr::reframe(value, NV, Major, minor, ploidy, multiplicity, karyotype, label, peak,
entropy = -sum(value*log2(max(value, .Machine$double.xmin)))) # entropy formula replacing zeros with minimum
# machine floating number
# Apply entropy cutoff
posterior = posterior %>%
dplyr::mutate(state = dplyr::case_when(
label %in% c('4N (Mutated: 1N)', '3N (Mutated: 1N)') | entropy > entropy_cutoff ~ 'Tier-2',
entropy <= entropy_cutoff & label %in% c("2N (Mutated: 1N)") ~ "HMD",
entropy <= entropy_cutoff & label %in% c("1N (Mutated: 1N)") ~ "LOH",
entropy <= entropy_cutoff & label %in% c("2N (Mutated: 2N)") ~ "CNLOH",
entropy <= entropy_cutoff & label %in% c("3N (Mutated: 2N)", "4N (Mutated: 2N)") ~ "AM"
))
return(posterior)
}
devtools::load_al()
devtools::load_all()
x = readRDS('~/Dropbox/2023.TAPACLOTH/Zenodo/results/msk_classified_with_priors_no_cutoff.rds')
priors = readRDS('~/Dropbox/2023.TAPACLOTH/Zenodo/results/pcawg_priors.rds')
entropy_cutoff
entropy_cutoff = 10000
rho = 0.01
karyotypes = c("1:0", "1:1", "2:0", "2:1", "2:2")
purity_error = .01
purity_error = .1
check_input(x)
cli::cli_alert_info("Performing classification")
x = idify(x)
id = x$input$id[1]
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes,
purity_error = purity_error
)
library(ggplot2)
posterior %>% ggplot()+geom_point(aes(x = NV, y = value, color = label))
p1 = posterior %>% ggplot()+geom_point(aes(x = NV, y = value, color = label))
purity_error
purity_error = 0
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes,
purity_error = purity_error
)
p2 = posterior %>% ggplot()+geom_point(aes(x = NV, y = value, color = label))
purity_error
library(patchwork)
p2+p1
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
map
old_map = map
purity_error = 0.1
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes,
purity_error = purity_error
)
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
old_map
map
classify_single_mutation = function(x, id, purity_error){
# Control for duplicates
if(info(x, id) %>% nrow() > 1){
cli_alert_warning(text = "More than one mutation mapped at: {.field {id}}")
info(x, id)
cli_alert_warning(text = "Keeping first row by default (check your input data)")
w = which(ids(x)==id)
x$data = x$data[-w[2:length(w)],]
}
# Compute model likelihood, posterior and entropy
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes,
purity_error = purity_error
)
# Maximum a posteriori classification
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
if (nrow(map) > 1) {
cli_alert_warning(text =
"With purity {.field {purity(x, id)}} karyotype {.field {map$karyotype}} with multiplicities {.field {map$multiplicity}} have the same likelihood")
cli_alert_warning(text =
"Simplest case will be selected: {.field {map$karyotype[1]}}")
map = map[1., ]
}
map = map %>% dplyr::select(label, state, value, entropy) %>% dplyr::rename(posterior = value) %>% dplyr::mutate(id = id)
fit = dplyr::right_join(input(x) %>% dplyr::select(colnames(genomic_data(x, PASS = TRUE)), id), map, by = 'id')
return(fit)
}
purity_error = .1
ids(x)[1]
tests = parallel::mclapply(X = ids(x)[1],
FUN = classify_single_mutation,
x = x,
purity_error = purity_error,
mc.cores = num_cores)
num_cores = 2
ids(x)[1:2]
purity_error
tests = parallel::mclapply(X = ids(x)[1:2],
FUN = classify_single_mutation,
x = x,
purity_error = purity_error,
mc.cores = num_cores)
tests
map
input(x)
input(x) %>%
dplyr::select(colnames(genomic_data(x, PASS = TRUE)), id)
map
posterior
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes,
purity_error = purity_error
)
posterior
compute_posterior
devtools::load_all()
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes,
purity_error = purity_error
)
posterior
posterior %>% View()
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
map
map %>%
dplyr::select(label, state, value, entropy) %>%
dplyr::rename(posterior = value) %>%
dplyr::mutate(id = id)
map = map %>%
dplyr::select(label, state, value, entropy, purity_error) %>%
dplyr::rename(posterior = value) %>%
dplyr::mutate(id = id)
dplyr::right_join(
input(x) %>%
dplyr::select(colnames(genomic_data(x, PASS = TRUE)), id),
map,
by = 'id')
classify_single_mutation = function(x, id, purity_error){
# Control for duplicates
if(info(x, id) %>% nrow() > 1){
cli_alert_warning(text = "More than one mutation mapped at: {.field {id}}")
info(x, id)
cli_alert_warning(text = "Keeping first row by default (check your input data)")
w = which(ids(x)==id)
x$data = x$data[-w[2:length(w)],]
}
# Compute model likelihood, posterior and entropy
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes,
purity_error = purity_error
)
# Maximum a posteriori classification
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
if (nrow(map) > 1) {
cli_alert_warning(text =
"With purity {.field {purity(x, id)}} karyotype {.field {map$karyotype}} with multiplicities {.field {map$multiplicity}} have the same likelihood")
cli_alert_warning(text =
"Simplest case will be selected: {.field {map$karyotype[1]}}")
map = map[1., ]
}
map = map %>%
dplyr::select(label, state, value, entropy, purity_error) %>%
dplyr::rename(posterior = value) %>%
dplyr::mutate(id = id)
fit = dplyr::right_join(
input(x) %>%
dplyr::select(colnames(genomic_data(x, PASS = TRUE)), id),
map,
by = 'id')
return(fit)
}
tests = parallel::mclapply(X = ids(x)[1:2],
FUN = classify_single_mutation,
x = x,
purity_error = purity_error,
mc.cores = num_cores)
tests
tests %>% do.call(rbind, .)
