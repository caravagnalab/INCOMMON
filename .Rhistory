cat("\n")
check_input(x)
cli::cli_alert_info("Performing classification")
x = idify(x)
classify_single_mutation = function(x, id){
# Control for duplicates
if(info(x, id) %>% nrow() > 1){
cli_alert_warning(text = "More than one mutation mapped at: {.field {id}}")
info(x, id)
cli_alert_warning(text = "Keeping first row by default (check your input data)")
w = which(ids(x)==id)
x$data = x$data[-w[2:length(w)],]
}
# Compute model likelihood, posterior and entropy
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes
)
# Maximum a posteriori classification
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
if (nrow(map) > 1) {
cli_alert_warning(text =
"With purity {.field {purity(x, id)}} karyotype {.field {map$karyotype}} with multiplicities {.field {map$multiplicity}} have the same likelihood")
cli_alert_warning(text =
"Simplest case will be selected: {.field {map$karyotype[1]}}")
map = map[1., ]
}
map = map %>% dplyr::select(label, state, value, entropy) %>% dplyr::rename(posterior = value) %>% dplyr::mutate(id = id)
list(
fit = dplyr::right_join(input(x) %>% dplyr::select(colnames(genomic_data(x, PASS = TRUE)), id), map, by = 'id'),
posterior = posterior
)
}
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
tests = do.call(rbind, tests) %>% t()
tests
tests['posterior',]
tests = sapply(ids(x), function(id) {
classify_single_mutation(x = x, id = id)
})
tests['posterior',]
tests['posterior',]
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores, )
ids(x)
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
tests
ids(x)
tests = do.call(rbind, tests) %>% t()
names(tests['posterior', ]) = ids(x)
tests['posterior', ]
tests['posterior', ]
names(tests['posterior', ])
names(tests['posterior', ]) = ids(x)
tests['posterior', ]
names(tests['posterior', ]) = seq("A":"F")
seq("A":"F")
tests['posterior', ]
seq(A:F)
letters
letters[1:10]
names(tests['posterior', ]) = letters[1:10]
tests['posterior', ]
names(tests['posterior', ]) = letters[1:8]
tests['posterior', ]
tests['posterior', ]
tests['posterior', ][[1]]
tests
rownames(tests)
colnames(tests)
colnames(tests['posterior', ])
colnames(tests['posterior', ]) = letters[1:8]
tests %>% dim()
colnames(tests) = letters[1:8]
tests
tests['posterior',]
tests['fit',]
tests['fit', ]
tests['fit', ] %>% do.call(rbind, .)
tests = sapply(ids(x), function(id) {
classify_single_mutation(x = x, id = id)
})
tests['fit', ] %>% do.call(rbind, .)
tests
tests = sapply(ids(x), function(id) {
classify_single_mutation(x = x, id = id)
})
tests
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
tests = do.call(rbind, tests) %>% t()
colnames(tests) = ids(x)
tests
devtools::document()
value
value = 0
-sum(value*log2(value))
log2(value)
-log2(value)
-value*log2(value)
min(0, -value*log2(value)
)
.Machine$double.eps
max(0, .Machine$double.eps)
.Machine$double.eps.xmin
.Machine$double.xmin
posterior
x
id
classify_single_mutation = function(x, id){
# Control for duplicates
if(info(x, id) %>% nrow() > 1){
cli_alert_warning(text = "More than one mutation mapped at: {.field {id}}")
info(x, id)
cli_alert_warning(text = "Keeping first row by default (check your input data)")
w = which(ids(x)==id)
x$data = x$data[-w[2:length(w)],]
}
# Compute model likelihood, posterior and entropy
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes
)
# Maximum a posteriori classification
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
if (nrow(map) > 1) {
cli_alert_warning(text =
"With purity {.field {purity(x, id)}} karyotype {.field {map$karyotype}} with multiplicities {.field {map$multiplicity}} have the same likelihood")
cli_alert_warning(text =
"Simplest case will be selected: {.field {map$karyotype[1]}}")
map = map[1., ]
}
map = map %>% dplyr::select(label, state, value, entropy) %>% dplyr::rename(posterior = value) %>% dplyr::mutate(id = id)
list(
fit = dplyr::right_join(input(x) %>% dplyr::select(colnames(genomic_data(x, PASS = TRUE)), id), map, by = 'id'),
# posterior = posterior
)
}
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
classify_single_mutation = function(x, id){
# Control for duplicates
if(info(x, id) %>% nrow() > 1){
cli_alert_warning(text = "More than one mutation mapped at: {.field {id}}")
info(x, id)
cli_alert_warning(text = "Keeping first row by default (check your input data)")
w = which(ids(x)==id)
x$data = x$data[-w[2:length(w)],]
}
# Compute model likelihood, posterior and entropy
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes
)
# Maximum a posteriori classification
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
if (nrow(map) > 1) {
cli_alert_warning(text =
"With purity {.field {purity(x, id)}} karyotype {.field {map$karyotype}} with multiplicities {.field {map$multiplicity}} have the same likelihood")
cli_alert_warning(text =
"Simplest case will be selected: {.field {map$karyotype[1]}}")
map = map[1., ]
}
map = map %>% dplyr::select(label, state, value, entropy) %>% dplyr::rename(posterior = value) %>% dplyr::mutate(id = id)
list(
fit = dplyr::right_join(input(x) %>% dplyr::select(colnames(genomic_data(x, PASS = TRUE)), id), map, by = 'id')
# posterior = posterior
)
}
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
tests
tests = do.call(rbind, tests) %>% t()
tests
tests['fit', ] %>% do.call(rbind, .)
output = x
output$classification = list()
cli::cli_h1(
"INCOMMON inference of copy number and mutation multiplicity for sample {.field {x$sample}}"
)
cat("\n")
check_input(x)
cli::cli_alert_info("Performing classification")
x = idify(x)
classify_single_mutation = function(x, id){
# Control for duplicates
if(info(x, id) %>% nrow() > 1){
cli_alert_warning(text = "More than one mutation mapped at: {.field {id}}")
info(x, id)
cli_alert_warning(text = "Keeping first row by default (check your input data)")
w = which(ids(x)==id)
x$data = x$data[-w[2:length(w)],]
}
# Compute model likelihood, posterior and entropy
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes
)
# Maximum a posteriori classification
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
if (nrow(map) > 1) {
cli_alert_warning(text =
"With purity {.field {purity(x, id)}} karyotype {.field {map$karyotype}} with multiplicities {.field {map$multiplicity}} have the same likelihood")
cli_alert_warning(text =
"Simplest case will be selected: {.field {map$karyotype[1]}}")
map = map[1., ]
}
map = map %>% dplyr::select(label, state, value, entropy) %>% dplyr::rename(posterior = value) %>% dplyr::mutate(id = id)
list(
fit = dplyr::right_join(input(x) %>% dplyr::select(colnames(genomic_data(x, PASS = TRUE)), id), map, by = 'id')
# posterior = posterior
)
}
if(parallel){
if(is.null(num_cores)) num_cores = as.integer(0.8*parallel::detectCores())
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
tests = do.call(rbind, tests) %>% t()
colnames(tests) = ids(x)
} else {
tests = sapply(ids(x), function(id) {
classify_single_mutation(x = x, id = id)
})
}
output$classification$fit = tests['fit', ] %>% do.call(rbind, .)
# output$classification$posterior = tests['posterior', ]
output$classification$parameters = dplyr::tibble(entropy_cutoff = entropy_cutoff, rho = rho)
cli::cli_alert_info('There are: ')
for (state in c('HMD', 'LOH', 'CNLOH', 'AM', 'Tier-2')) {
N  = classification(output) %>% dplyr::filter(state == !!state) %>% nrow()
cli::cli_bullets(c("*" = paste0("N = ", N, ' mutations (', state, ')')))
}
mean_ent = classification(output) %>% dplyr::pull(entropy) %>% mean()
min_ent = classification(output) %>% dplyr::pull(entropy) %>% min()
max_ent = classification(output) %>% dplyr::pull(entropy) %>% max()
cli::cli_alert_info(
'The mean classification entropy is {.field {round(mean_ent, 2)}} (min: {.field {round(min_ent, 2)}}, max: {.field {round(max_ent, 2)}})'
)
output
output$classification
classification(output)
posterior(output)
y = x
x = output
x
sample = x$classification$fit$sample[1]
subset_sample(x, sample = sample)
x = subset_sample(x, sample = sample)
x
x$classification
ids(x)
id = ids(x)[1]
posterior(x, id = id)
parameters(x)
parameters(x)$entropy_cutoff
karyotypes
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes)
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = as.vector(karyotypes))
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = list(karyotypes))
paste(karyotypes)
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = paste(karyotypes))
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = paste(karyotypes, collapse = ' '))
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = paste(karyotypes, collapse = ' ')) %>% pull(karyotypes)
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = paste(karyotypes, collapse = ' ')) %>% dplyr::pull(karyotypes)
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = paste(karyotypes, collapse = ' ')) %>% dplyr::pull(karyotypes) %>% strsplit()
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = paste(karyotypes, collapse = ' ')) %>% dplyr::pull(karyotypes) %>% strsplit(split = ' ')
dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = paste(karyotypes, collapse = ' ')) %>% dplyr::pull(karyotypes) %>% strsplit(split = ' ')[[1]]
# output$classification$posterior = tests['posterior', ]
output$classification$parameters = dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = list(karyotypes))
output$classification$parameters
x$classification$parameters
x = output
x$classification$parameters
parameters
parameters(karyotypes)$karyotypes[[1]]
parameters(x)$karyotypes[[1]]
parameters(x)$karyotypes
unlist(parameters(x)$karyotypes)
priors
compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = parameters(x)$entropy_cutoff,
rho = parameters(x)$entropy_cutoff$rho,
karyotypes = unlist(parameters(x)$karyotypes)
)
compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = parameters(x)$entropy_cutoff,
rho = parameters(x)$rho,
karyotypes = unlist(parameters(x)$karyotypes)
)
posterior(x, id = id)
devtools::load_all()
posterior(x, id = id)
posterior(x, id = id)
devtools::load_all()
posterior(x, id = id)
plot_classification(output, id)
plot_classification(x = output, sample = sample,assembly = T)
devtools::load_all()
plot_classification(x = output, sample = sample,assembly = T)
names(x)
names(x$classification)
setwd('~/Documents/GitHub/CNAqc/')
CNAqc:::advanced_phasing
INCOMMON::classify
setwd('~/Documents/GitHub/INCOMMON/')
devtools::load_all()
library(INCOMMON)
library(dplyr)
library(DT)
sample = 'P-0002081'
genomic_data = MSK_genomic_data %>% filter(sample == !!sample)
clinical_data = MSK_clinical_data %>% filter(sample == !!sample)
print(genomic_data)
print(clinical_data)
x = init(genomic_data = genomic_data,
clinical_data = clinical_data,
gene_roles = cancer_gene_census)
print(x)
priors = pcawg_priors
entropy_cutoff = 0.2
rho = 0.01
karyotypes = c("1:0", "1:1", "2:0", "2:1", "2:2")
stopifnot(inherits(x, "INCOMMON"))
if(is.null(entropy_cutoff)) entropy_cutoff = 1
# Output
output = x
output$classification = list()
cli::cli_h1(
"INCOMMON inference of copy number and mutation multiplicity for sample {.field {x$sample}}"
)
cat("\n")
check_input(x)
cli::cli_alert_info("Performing classification")
x = idify(x)
classify_single_mutation = function(x, id){
# Control for duplicates
if(info(x, id) %>% nrow() > 1){
cli_alert_warning(text = "More than one mutation mapped at: {.field {id}}")
info(x, id)
cli_alert_warning(text = "Keeping first row by default (check your input data)")
w = which(ids(x)==id)
x$data = x$data[-w[2:length(w)],]
}
# Compute model likelihood, posterior and entropy
posterior = compute_posterior(
NV = NV(x, id),
DP = DP(x, id),
gene = gene(x, id),
priors = priors,
tumor_type = tumor_type(x, id),
purity = purity(x, id),
entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = karyotypes
)
# Maximum a posteriori classification
map = posterior %>%
dplyr::filter(NV == NV(x, id)) %>%
dplyr::filter(value == max(value)) %>%
dplyr::ungroup()
if (nrow(map) > 1) {
cli_alert_warning(text =
"With purity {.field {purity(x, id)}} karyotype {.field {map$karyotype}} with multiplicities {.field {map$multiplicity}} have the same likelihood")
cli_alert_warning(text =
"Simplest case will be selected: {.field {map$karyotype[1]}}")
map = map[1., ]
}
map = map %>% dplyr::select(label, state, value, entropy) %>% dplyr::rename(posterior = value) %>% dplyr::mutate(id = id)
fit = dplyr::right_join(input(x) %>% dplyr::select(colnames(genomic_data(x, PASS = TRUE)), id), map, by = 'id')
return(fit)
}
if(parallel){
if(is.null(num_cores)) num_cores = as.integer(0.8*parallel::detectCores())
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
tests = do.call(rbind, tests)
} else {
tests = lapply(ids(x), function(id) {
classify_single_mutation(x = x, id = id)
})
}
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
num_cores=2
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
tests
tests = do.call(rbind, tests)
tests
lapply(ids(x), function(id) {
classify_single_mutation(x = x, id = id)
})
parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
tests
tests = parallel::mclapply(X = ids(x),
FUN = classify_single_mutation,
x = x,
mc.cores = num_cores)
tests
tests %>% do.call(rbind, .)
output$classification$fit = tests %>% do.call(rbind, .)
output$classification$parameters = dplyr::tibble(entropy_cutoff = entropy_cutoff,
rho = rho,
karyotypes = list(karyotypes))
output$classification$priors = priors
classification(output)
classification(output) %>% dplyr::filter(state == !!state)
classification(output) %>% dplyr::filter(state == !!state) %>% nrow()
cli::cli_alert_info('There are: ')
for (state in c('HMD', 'LOH', 'CNLOH', 'AM', 'Tier-2')) {
N  = classification(output) %>% dplyr::filter(state == !!state) %>% nrow()
cli::cli_bullets(c("*" = paste0("N = ", N, ' mutations (', state, ')')))
}
