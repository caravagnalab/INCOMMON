data$z0[1]*data$ccf_clades_n[1,1],
data$z0[1]*data$ccf_clades_n[2,1],
data$zminus*data$ccf_clades_n[1,2],
data$zminus*data$ccf_clades_n[2,2],
z0[1],
zminus)
)
pp = plot_posterior_pred(draws,obs)
pp
library(cmdstanr)
library(rjson)
library(tidyverse)
source("scripts/utils.R")
file = "stan_models/clades_counts_integration.stan"
model = cmdstan_model(file, force_recompile = TRUE)
x = readRDS(paste0("data/data_clusters.rds"))
# RM238
patient = 'RM238'
ccf_p = matrix(
c(
get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'POS', cluster = 'S1'),
get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'POS', cluster = 'S2'),
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'POS', cluster = 'S1'),
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'POS', cluster = 'S2')),
nrow = 2,
ncol = 2
)
ccf_n = matrix(
c(
get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'NEG', cluster = 'S1'),
get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'NEG', cluster = 'S2'),
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'NEG', cluster = 'S1'),
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'NEG', cluster = 'S2')),
nrow = 2,
ncol = 2
)
z0 = c(
get_total_counts(data = x, patient = patient, timepoint = 'T1', epistate = 'NEG'), # Mean N cells at T1-
get_total_counts(data = x, patient = patient, timepoint = 'T1', epistate = 'POS'), # Mean N cells at T1+
0, # Variance N T1-
0, # Variance N T1+
0 # Covariance T1- vs T1+
)
zminus = get_total_counts(data = x, patient = patient, timepoint = 'T2', epistate = 'NEG') # Mean N cells at T2-
zplus = get_total_counts(data = x, patient = patient, timepoint = 'T2', epistate = 'POS') # Mean N cells at T2+
t0 = get_dates(data = x,patient)[1]
t1 = get_dates(data = x,patient)[2]
m_clades = c(
get_m_cluster(data = x, patient = patient, clusters = 'S1'),
get_m_cluster(data = x, patient = patient, clusters = 'S2')
)
mu = get_mu(patient)
l = get_genome_length(patient)
# WBC not available
lambda_neg_wbc = log(zminus/z0[1])/(t1-t0)
loc_mrca = -log(z0[1])/lambda_neg_wbc
data = list(
N_clades = 2,
min_ccf = 0.05, # test dependence on this threshold
max_ccf = 0.3,
m_clades = m_clades,
ccf_clades_p =  ccf_p,
ccf_clades_n =  ccf_n,
n_times = 1,
times = t1,
# n_times = n_times+1,
# times  = c(times,t1),
z0 = z0,
# ztot = ztot,
t0 = t0,
# z1 = z1,
zminus = zminus,
zplus = zplus,
# t_min = -50,
loc_mrca = loc_mrca,
scale = 20,
ms = -0.5,
sigma = 0.5,
alpha_lambda = lambda_neg_wbc*10,
beta_lambda = 10,
alpha_p = 0.1,
beta_p = 50,
alpha_n = 0.1,
beta_n = 50,
mu = mu$mean, # Fix to estimate from T1-
l = l %>% filter(karyotype == "1:1") %>% pull(length)
)
sm = model$sample(
data = data,
chains = 1,
iter_warmup = 1000,
iter_sampling = 5000,
seed = 1933,
adapt_delta = 0.99,
max_treedepth = 50,
parallel_chains = 1
)
sm$cmdstan_summary()
sm$cmdstan_summary() %>% View()
draws = rbind(get_posterior(sm),get_prior(sm))
draws$variable = as.vector(draws$variable)
inference = plot_inference(draws,gt = NULL)
params = unique(draws$variable)[grepl(x = draws$variable %>% unique(),pattern = "pred")]
obs = tibble(
variable = params[params != "N_clades_pred"],
exp = c(data$m_clades,
data$z0[2]*data$ccf_clades_p[1,1],
data$z0[2]*data$ccf_clades_p[2,1],
data$zplus*data$ccf_clades_p[1,2],
data$zplus*data$ccf_clades_p[2,2],
data$z0[1]*data$ccf_clades_n[1,1],
data$z0[1]*data$ccf_clades_n[2,1],
data$zminus*data$ccf_clades_n[1,2],
data$zminus*data$ccf_clades_n[2,2],
z0[1],
zminus)
)
pp = plot_posterior_pred(draws,obs)
inference
pp
get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'NEG', cluster = 'S1')
get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'NEG', cluster = 'S2')
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'NEG', cluster = 'S1')
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'NEG', cluster = 'S2')
library(cmdstanr)
library(rjson)
library(tidyverse)
source("scripts/utils.R")
file = "stan_models/clades_counts_integration.stan"
model = cmdstan_model(file, force_recompile = TRUE)
x = readRDS(paste0("data/data_clusters.rds"))
# RM238
patient = 'RM238'
ccf_p = matrix(
c(
get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'POS', cluster = 'S1'),
get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'POS', cluster = 'S2'),
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'POS', cluster = 'S1'),
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'POS', cluster = 'S2')),
nrow = 2,
ncol = 2
)
ccf_n = matrix(
c(
# get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'NEG', cluster = 'S1'),
1e-5,
get_ccf(data = x, patient = patient, timepoint = 'T1', epistate = 'NEG', cluster = 'S2'),
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'NEG', cluster = 'S1'),
get_ccf(data = x, patient = patient, timepoint = 'T2', epistate = 'NEG', cluster = 'S2')),
nrow = 2,
ncol = 2
)
z0 = c(
get_total_counts(data = x, patient = patient, timepoint = 'T1', epistate = 'NEG'), # Mean N cells at T1-
get_total_counts(data = x, patient = patient, timepoint = 'T1', epistate = 'POS'), # Mean N cells at T1+
0, # Variance N T1-
0, # Variance N T1+
0 # Covariance T1- vs T1+
)
zminus = get_total_counts(data = x, patient = patient, timepoint = 'T2', epistate = 'NEG') # Mean N cells at T2-
zplus = get_total_counts(data = x, patient = patient, timepoint = 'T2', epistate = 'POS') # Mean N cells at T2+
t0 = get_dates(data = x,patient)[1]
t1 = get_dates(data = x,patient)[2]
m_clades = c(
get_m_cluster(data = x, patient = patient, clusters = 'S1'),
get_m_cluster(data = x, patient = patient, clusters = 'S2')
)
mu = get_mu(patient)
l = get_genome_length(patient)
# WBC not available
lambda_neg_wbc = log(zminus/z0[1])/(t1-t0)
loc_mrca = -log(z0[1])/lambda_neg_wbc
data = list(
N_clades = 2,
min_ccf = 0.05, # test dependence on this threshold
max_ccf = 0.3,
m_clades = m_clades,
ccf_clades_p =  ccf_p,
ccf_clades_n =  ccf_n,
n_times = 1,
times = t1,
# n_times = n_times+1,
# times  = c(times,t1),
z0 = z0,
# ztot = ztot,
t0 = t0,
# z1 = z1,
zminus = zminus,
zplus = zplus,
# t_min = -50,
loc_mrca = loc_mrca,
scale = 20,
ms = -0.5,
sigma = 0.5,
alpha_lambda = lambda_neg_wbc*10,
beta_lambda = 10,
alpha_p = 0.1,
beta_p = 50,
alpha_n = 0.1,
beta_n = 50,
mu = mu$mean, # Fix to estimate from T1-
l = l %>% filter(karyotype == "1:1") %>% pull(length)
)
sm = model$sample(
data = data,
chains = 1,
iter_warmup = 1000,
iter_sampling = 5000,
seed = 1933,
adapt_delta = 0.99,
max_treedepth = 50,
parallel_chains = 1
)
sm$cmdstan_summary()
draws = rbind(get_posterior(sm),get_prior(sm))
draws$variable = as.vector(draws$variable)
inference = plot_inference(draws,gt = NULL)
params = unique(draws$variable)[grepl(x = draws$variable %>% unique(),pattern = "pred")]
obs = tibble(
variable = params[params != "N_clades_pred"],
exp = c(data$m_clades,
data$z0[2]*data$ccf_clades_p[1,1],
data$z0[2]*data$ccf_clades_p[2,1],
data$zplus*data$ccf_clades_p[1,2],
data$zplus*data$ccf_clades_p[2,2],
data$z0[1]*data$ccf_clades_n[1,1],
data$z0[1]*data$ccf_clades_n[2,1],
data$zminus*data$ccf_clades_n[1,2],
data$zminus*data$ccf_clades_n[2,2],
z0[1],
zminus)
)
pp = plot_posterior_pred(draws,obs)
pp
getwd()
setwd('~/Dropbox/2023.TAPACLOTH/Revisions/')
synth = readRDS('./results/higher_ploidy/pcawg_derived_sim_accuracy_larger.rds')
synth$sample %>% unique() %>% length()
library(tidyverse)
synth$sample %>% unique() %>% length()
get_conf_matrix = function(x){
cm_df = x %>%
group_by(true_class, map_class) %>%
reframe(n = n())
conf_matrix = cm_df %>%
pivot_wider(names_from = map_class, values_from = n, values_fill = 0) %>%
column_to_rownames(var = "true_class")
# Convert to a matrix
conf_matrix = as.matrix(conf_matrix)
return(conf_matrix)
}
# Function to compute Precision, Recall, and F1-Score from a confusion matrix
compute_metrics_from_confusion = function(conf_matrix) {
accuracy = sum(diag(conf_matrix))/sum(conf_matrix)
# Precision, Recall, and F1-Score for each class
precision <- diag(conf_matrix) / colSums(conf_matrix)
recall <- diag(conf_matrix) / rowSums(conf_matrix)
f1_score <- 2 * (precision * recall) / (precision + recall)
# Handling NaN in F1-Score where precision + recall might be zero
f1_score[is.na(f1_score)] <- 0
# Macro-averaged metrics
macro_precision <- mean(precision, na.rm = TRUE)
macro_recall <- mean(recall, na.rm = TRUE)
macro_f1 <- mean(f1_score, na.rm = TRUE)
# Results
tibble(
class = names(precision),
accuracy = accuracy,
Precision = precision,
Recall = recall,
F1 = f1_score,
macro_precision = macro_precision,
macro_recall = macro_recall,
macro_f1 = macro_f1
)
}
fit_purity = function(x){
what = x %>%
group_by(sample) %>%
reframe(in_pi = unique(purity), out_pi = unique(purity_pred))
model = lm(out_pi ~ in_pi, data = what)
std_residuals_threshold = 2
cooks_distance_threshold = 4/nrow(what)
what %>%
mutate(
fitted = fitted(model),                            # Fitted values
residuals = resid(model),                          # Residuals
std_residuals = residuals/0.05,                  # Standardized residuals
r2 = summary(model)$r.squared
) %>%
mutate(outlier = (abs(std_residuals) > 1.96))
}
test_purity = function(x){
lapply(seq(0.25, 0, -0.05), function(th){
what = x %>%
filter(1-abs(purity-purity_pred) >= 1-th)
conf_matrix = get_conf_matrix(what)
metrics = compute_metrics_from_confusion(conf_matrix)
metrics$threshold = 1-th
metrics$N = rowSums(conf_matrix)
return(metrics)
}) %>% do.call(rbind, .)
}
test_posterior = function(x, filter_purity = FALSE){
if(filter_purity) {
outlier_samples = fit_purity(x = x) %>% filter(outlier) %>% pull(sample) %>% unique()
x = x %>% filter(!(sample %in% outlier_samples))
}
lapply(seq(min(x$map_posterior), max(x$map_posterior)-0.01, 0.01), function(th){
what = x %>%
filter(map_posterior >= th)
conf_matrix = get_conf_matrix(what)
metrics = compute_metrics_from_confusion(conf_matrix)
metrics$threshold = th
metrics$N = rowSums(conf_matrix)
return(metrics)
}) %>% do.call(rbind, .)
}
get_conf_matrix = function(x){
cm_df = x %>%
group_by(true_class, map_class) %>%
reframe(n = n())
conf_matrix = cm_df %>%
pivot_wider(names_from = map_class, values_from = n, values_fill = 0) %>%
column_to_rownames(var = "true_class")
# Convert to a matrix
conf_matrix = as.matrix(conf_matrix)
return(conf_matrix)
}
# Function to compute Precision, Recall, and F1-Score from a confusion matrix
compute_metrics_from_confusion = function(conf_matrix) {
accuracy = sum(diag(conf_matrix))/sum(conf_matrix)
# Precision, Recall, and F1-Score for each class
precision <- diag(conf_matrix) / colSums(conf_matrix)
recall <- diag(conf_matrix) / rowSums(conf_matrix)
f1_score <- 2 * (precision * recall) / (precision + recall)
# Handling NaN in F1-Score where precision + recall might be zero
f1_score[is.na(f1_score)] <- 0
# Macro-averaged metrics
macro_precision <- mean(precision, na.rm = TRUE)
macro_recall <- mean(recall, na.rm = TRUE)
macro_f1 <- mean(f1_score, na.rm = TRUE)
# Results
tibble(
class = names(precision),
accuracy = accuracy,
Precision = precision,
Recall = recall,
F1 = f1_score,
macro_precision = macro_precision,
macro_recall = macro_recall,
macro_f1 = macro_f1
)
}
fit_purity = function(x){
what = x %>%
group_by(sample) %>%
reframe(in_pi = unique(purity), out_pi = unique(purity_pred))
model = lm(out_pi ~ in_pi, data = what)
std_residuals_threshold = 2
cooks_distance_threshold = 4/nrow(what)
what %>%
mutate(
fitted = fitted(model),                            # Fitted values
residuals = resid(model),                          # Residuals
std_residuals = residuals/0.05,                  # Standardized residuals
r2 = summary(model)$r.squared
) %>%
mutate(outlier = (abs(std_residuals) > 1.96))
}
test_purity = function(x){
lapply(seq(0.25, 0, -0.05), function(th){
what = x %>%
filter(1-abs(purity-purity_pred) >= 1-th)
conf_matrix = get_conf_matrix(what)
metrics = compute_metrics_from_confusion(conf_matrix)
metrics$threshold = 1-th
metrics$N = rowSums(conf_matrix)
return(metrics)
}) %>% do.call(rbind, .)
}
test_posterior = function(x, filter_purity = FALSE){
if(filter_purity) {
outlier_samples = fit_purity(x = x) %>% filter(outlier) %>% pull(sample) %>% unique()
x = x %>% filter(!(sample %in% outlier_samples))
}
lapply(seq(min(x$map_posterior), max(x$map_posterior)-0.01, 0.01), function(th){
what = x %>%
filter(map_posterior >= th)
conf_matrix = get_conf_matrix(what)
metrics = compute_metrics_from_confusion(conf_matrix)
metrics$threshold = th
metrics$N = rowSums(conf_matrix)
return(metrics)
}) %>% do.call(rbind, .)
}
plot_class_metrics = function(x, xlabel){
x %>%
mutate(class = factor(class, levels = c('m=1', 'm=k', '1<m<k'))) %>%
tidyr::pivot_longer(cols = c('Precision', 'Recall', 'F1'), names_to = 'metric', values_to = 'value') %>%
ggplot(aes(x = threshold, y = value, group = metric, color = metric))+
geom_line()+
geom_point()+
scale_color_manual(values = c('Precision' = 'goldenrod1', 'Recall' = 'darkorange', 'F1' = 'deeppink3')) +
facet_wrap(~class)+
CNAqc:::my_ggplot_theme(cex = .8)+
xlab(xlabel)+ylab('')
}
plot_overall_metrics = function(x, xlabel){
x %>%
filter(class=='m=1') %>%
select(accuracy, starts_with('macro'), threshold) %>%
rename('Precision' = 'macro_precision', 'Recall' = 'macro_recall', 'F1' = 'macro_f1', 'Accuracy' = 'accuracy') %>%
tidyr::pivot_longer(cols = c('Precision', 'Recall', 'F1', 'Accuracy'), names_to = 'metric', values_to = 'value') %>%
ggplot(aes(x = threshold, y = value, group = metric, color = metric))+
geom_line()+
geom_point()+
scale_color_manual(values = c('Precision' = 'goldenrod1', 'Recall' = 'darkorange', 'F1' = 'deeppink3', 'Accuracy' = 'purple3')) +
CNAqc:::my_ggplot_theme(cex = .8)+
xlab(xlabel)+ylab('')+
ylim(.4,1)
}
plot_N = function(x, xlabel){
x %>%
ggplot(aes(x = threshold, y = N, group = class, color = class))+
geom_line()+
geom_point()+
scale_color_manual(values = c('m=1' = 'forestgreen', 'm=k' = 'steelblue', '1<m<k' = 'indianred2')) +
CNAqc:::my_ggplot_theme(cex = .8)+
xlab(xlabel)+ylab('N mutations')
}
plot_purity = function(x){
# what = x %>%
#   group_by(sample) %>%
#   reframe(in_pi = unique(purity), out_pi = unique(purity_pred))
#
# model = lm(out_pi ~ in_pi, data = what)
# r_squared <- summary(model)$r.squared
what = fit_purity(x)
what %>%
ggplot(aes(x = in_pi, y = out_pi))+
geom_smooth(method = "lm", se = TRUE, col = "blue") +
geom_point(aes(color = outlier), size = 1)+
scale_color_manual(values = c('TRUE' = 'indianred2', 'FALSE' = 'black'))+
geom_text(
data = what %>% slice_head(n = 1),
aes(x = -Inf, y = Inf,
label = paste0('R^2 = ', round(r2,2))),
hjust = -0.1, vjust = 1.5, size = 5, color = "black")+
CNAqc:::my_ggplot_theme(cex = .8)+
xlab('Input purity')+ylab('Predicted purity')+
xlim(0.2,1)+ylim(0.2,1)
}
plot_dp_vs_k = function(x){
x %>%
ggplot(aes(x = factor(ploidy), y = DP))+
geom_boxplot() +
CNAqc:::my_ggplot_theme(cex = .8)+
xlab('Total CN')+ylab('DP')+
ylim(0,400)
}
plot_dp_dist = function(x){
q = quantile(x$DP)
x %>%
ggplot(aes(x = DP))+
geom_histogram(fill = 'deepskyblue') +
geom_vline(xintercept = q['25%'], linetype = 'longdash', color = 'purple3')+
geom_vline(xintercept = q['50%'], linetype = 'longdash', color = 'purple3')+
geom_vline(xintercept = q['75%'], linetype = 'longdash', color = 'purple3')+
CNAqc:::my_ggplot_theme(cex = .8)+
xlab('DP')+ylab('')+
xlim(0,400)
}
plot_posterior_vs_class = function(x){
tcga %>%
group_by(map_class) %>%
reframe(mp = median(map_posterior), across(everything())) %>%
ggplot(aes(x = map_class, y = map_posterior)) +
geom_violin()+
geom_jitter(width = .1, alpha = .1, color = 'blue')+
geom_hline(data = . %>% arrange(mp) %>% slice_head(n=1), aes(yintercept = mp), linetype = 'longdash')+
CNAqc:::my_ggplot_theme(cex = .8)+
xlab('MAP Class')+ylab('Posterior probability')
}
synth_purity = test_purity(synth %>% rename(purity = purity_true))
synth_posterior = test_posterior(synth, filter_purity = FALSE)
synth %>% rename(true_class = class)
synth_purity = test_purity(synth %>% rename(purity = purity_true))
synth = synth %>% rename(true_class = class)
synth_purity = test_purity(synth %>% rename(purity = purity_true))
synth_posterior = test_posterior(synth, filter_purity = FALSE)
synth_posterior_filtered = test_posterior(synth %>% rename(purity = purity_true), filter_purity = TRUE)
p_synth_overall_posterior = plot_overall_metrics(x = synth_posterior_filtered, xlabel = 'Posterior threshold')
p_synth_overall_purity = plot_overall_metrics(x = synth_purity, xlabel = 'Purity accuracy threshold')
# p_tcga_overall_filtered = plot_overall_metrics(x = tcga_posterior_filtered, xlabel = 'Posterior threshold')
p_synth_purity = plot_purity(x = synth %>% rename(purity = purity_true))
p_synth_dp_vs_k = plot_dp_vs_k(x = synth %>% rename(ploidy = ploidy_true))
p_synth_dp_dist = plot_dp_dist(x = synth)
plot_summary_synth = wrap_plots(p_synth_overall_posterior, p_synth_overall_purity, p_synth_purity, p_synth_dp_vs_k, p_synth_dp_dist,
guides = 'auto',
design = 'AAABBB\nCCDDEE')+
plot_annotation(title = paste0('Test on synthetic data (N = ', length(unique(synth$sample)), ' samples, M = ', nrow(synth), ' mutations)'),
tag_levels = 'a')&
theme(legend.position = 'bottom')
library(patchwork)
plot_summary_synth = wrap_plots(p_synth_overall_posterior, p_synth_overall_purity, p_synth_purity, p_synth_dp_vs_k, p_synth_dp_dist,
guides = 'auto',
design = 'AAABBB\nCCDDEE')+
plot_annotation(title = paste0('Test on synthetic data (N = ', length(unique(synth$sample)), ' samples, M = ', nrow(synth), ' mutations)'),
tag_levels = 'a')&
theme(legend.position = 'bottom')
plot_summary_synth
